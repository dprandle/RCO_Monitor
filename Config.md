# Config File

The config file is in json format with comments of the form "//" added (any text from "//" up to the line ending will be ignored). Empty lines are also allowed.

Json is a well documented format - check out [this](https://www.tutorialspoint.com/json/json_quick_guide.htm) to learn about it.

## Purpose

The config file allows you to add multiple loggers, each with their own scan period (scan the radios every scan_period ms and add an entry to the log file if a condition is true), and different conditions for triggering a save. Each logger generates its own log file with the name of the file as the json obj name plus auto generated date/hour, and it will be located in the folder specified by "dir_path". This should be an absolute path, not a relative path.

You can set up multiple loggers by including multiple entrees in the loggers json object. Not including items in the config file will cause the radio monitor program to use default values. For any of the logged properties (ptt_status, squelch_status, forward_power, reverse_power, vswr, agc, line_level), not including them will make it so they are not logged as a column in the CSV file. For a given propery, including only the "title" sub-property will cause the item to be logged, but it will never trigger a log entry to be added itself - ie it is a passive property that is logged when something else triggers the log.

## Default Config

The default config file shipped with the radio logger is [here](cfg/RCO_config.json). This only has two loggers, one that scans every 250ms and logs an entry when any TX is keyed or RX has open squelch, and the other scans every 1000ms and logs an entry every time there is a high VSWR on a transmitter.

A custom config for ANCE can be found [here](cfg/ANCE_config.json). This has four loggers: one logs everything every 500ms, two do the same as the two RCO loggers, and an additional logger scans every 100 ms and logs entrees when either PTT or squelch status changes (but not continually while active).

The dir_path for the ANCE config file assumes the PI has usbmount installed and a thumb drive is in the PI. This is so it is easy to pull the logs from the PI. If there is no thumb drive (or usbmount is not installed), the dir_path reverts to /home/ubuntu/csvlogs which is the home path on the PI. In general, if the path provided by dir_path can't be found, /home/ubuntu/csvlogs will be used.

## Logging Conditions

As mentioned above, the properties that can appear as columns in the CSV log file generated by each logger are:

### Transmitters
ptt_status, forward_power, reverse_power, vswr

### Receivers
squelch_status, agc, line_level

Ommitting any of these properties in the config will cause them to not appear in the csv. If you omit all items for Transmitters then transmitters will not appear in the CSV file at all, the same is true for receiver properties. For example, the "High_VSWR_1000ms" logger will not include any entrees for receivers in the CSV file it generates.

Each of the items above can trigger a log entry to be added to the csv log file. When this happens, all radios parameters for all radios that are included in the csv are logged.

For example, to log all included radio properties every scan, you could do:

```json
{
    // etc
    "period": 500,
    "ptt_status": {
        "title": "PTT",
        "equal":"OFF | LOCAL | REMOTE | TEST_RF"
    },
    "squelch_status": {
        "title": "Squelch"
    },
    "forward_power": {
        "title": "Fwd Pwr"
    },
    "vswr": {
        "title": "VSWR"
    },
    "agc": {
        "title": "AGC"
    },
    "line_level": {
        "title": "Line Lvl"
    }
}
```

Since the condition to log ptt_status includes all possible states, this would always be true and an entry would be added to the csv log file every 500ms. The entry would include not just include PTT info, it would include squelch_status, forward_power, vswr, agc, and line_level for all radios connected to the network (as scanned at startup). Notice, it would not include reverse_power, since it was ommitted.

Say instead you had the following:
```json
{
    // etc
    "period": 500,
    "ptt_status": {
        "title": "PTT",
        "equal":"LOCAL | REMOTE"
    },
    "agc": {
        "title": "AGC"
    },
}
```

This would scan every 500ms, but only add an entry to the csv log file if one of the connected transmitters was keyed (either from its REM connector, or from a mic plugged in to the front, but not from pressing the Test key button on the front panel). Even though an entry is only added if one of the transmitters keys, the entry will still include the AGC level for all connected receivers.

## Simulation

If the top level property "simulate_radios" is set to true, ie as shown here:

```json
{
    "logging_enabled": true,
    "simulate_radios": true,
    "simulation_period": 1000,
    "simulation_high_vswr_period_count": 5,
    "simulation_random_squelch_break_period_count": 7,
    "ip_lower_bound": 10,
    "ip_upper_bound": 55,
    /// ETC
}
```

then the radio monitor program will not attempt to connect to any radios, and instead will generate fake simulated radios. The purpose of this is to quickly/easily test your config settings making sure logs are generating when/where/how you want them. It is also to stress test the PI with large numbers of radios and large amounts of data, and to get an idea of how big the generated files might be (ie is your thumb drive big enough for the duration?).

The ip upper and lower bounds are used to determine the number of radios to create for the simulation. The total number of radios will be ip_upper_bound - ip_lower_bound + 1. Keep in mind, radios are created in sets so if the previous calc results in an odd number, it will be rounded down to the closest even number. This means if you say ip_upper_bound = 10 and ip_lower_bound = 10, the result of 1 will round to 0 and no radios will be made.

As mentioned, pairs of TX/RX with same frequency are generated, and an even number of UHF/VHF radio sets are generated, or if there are an odd number of sets then an extra VHF set is chosen. For example, ip_upper_bound = 55 and ip_lower_bound = 10, then 23 radio sets will be generated (55 - 10 + 1 = 46 radios = 23 radio sets), with 11 being UHF and 12 being VHF.

The simulation is very simple. but varys every parameter so that stuff can be tested. There are three things that are simulated.

### PTT/Squelch Loop

Every simulation_period ms (see config option above), a transmitter is keyed and its associated receiver is set to open squelch. The TX forward power is also set to 12, reverse kept at 0, and VSWR set to 1 (it is -1.0 when PTT is off). The RX has its agc set to 2.6 and its line level set to -8.0. It starts with the first radio set, and every period moves to the next radio set while returning the previous radio set to normal. IE

after simulation_period ms
F1(TX-KEYED RX-OPEN) F2(TX RX) F3(TX RX)

after 2*simulation_period ms
F1(TX RX) F2(TX-KEYED RX-OPEN) F3(TX RX)

etc..

Also, the PTT key the first time through the radios is Local, the next time Remote, the next time Test RF, and this repeats.

### Random Open Squelch

In additon to the above, every simulation_random_squelch_break_period_count simulation periods, a random receiver will be set to open squelch for one simulation_period. It's agc will be set to 2.2 and line level to -8.0, and returned to normal after one simulation period. The chosen receiver will always be different than the receiver from the PTT/Squelch Loop.

### TX High VSWR

Every simulation_high_vswr_period_count simulation periods, the TX keyed by the PTT/Squelch Loop is given a high VSWR of 2.5 and the associated reflected power of 2.2041 for a single simulation period.

This should cover all properties and allow testing of property conditions and file sizes.

## Reference

Below is a commented json config to show all options for all variables. Defaults values are given, except for loggers which defaults to empty. If the value
isn't provided in the config file, the default value is used.

```json
{
    // bool - If false all loggers are disabled - no csv files will be generated
    "logging_enabled": true,

    // bool - If true no radios will be scanned for on startup. Instead radios will be generated and simulated as pointed
    // out in simulation section. Number of simulated radios is ip_lower_limit - ip_upper_limit + 1. Will round this number
    // down to closest even number as radio sets of the same frequency are always generated (never a single TX or single RX)
    "simulate_radios": false,

    // int - How often the simulated radios have their PTT/Squelch changed in the PTT/Squelch Loop - IE for 2000 as default
    // every 2000 ms the next TX/RX pair would be keyed/open squelch and the previous returned to normal.
    // Ignored if simulate_radios is false
    "simulation_period": 2000,

    // int - Every simulation_periods * simulation_random_squelch_break_period_count ms (ie 2000 * 5 = 10s) a random receiver 
    // will be set to open squelch for a single simulation period - the receiver chosen will always be different than the 
    // one open squelch due to the PTT/Squelch Loop. 
    // Ignored if simulate_radios is false
    "simulation_random_squelch_break_period_count": 5,

    // int - Every simulation_periods * simulation_high_vswr_period_count ms (ie 2000 * 30 = 60s) the TX keyed by PTT/Squelch Loop
    // will have its VSWR set to 2.5 and reverse power to 2.2041 for a single simulation period.
    // Ignored if simulate_radios is false
    "simulation_high_vswr_period_count": 30,

    // int - for the subnet 192.168.102, which number in the last octet to scan FROM for the startup IP radio scan. IE for default
    // of 10, IP scan starts at 192.168.102.10
    "ip_lower_bound": 10,

    // int - for the subnet 192.168.102, which number in the last octet to scan TO for the startup IP radio scan. IE for default
    // of 13, IP scan ends at 192.168.102.13
    "ip_upper_bound": 13,

    // int - if a radio stops communicating (it must be found at startup to qualify to reconnect), how many times should we retry 
    // connecting. Note that a disconnected radio can cause problems for logging data for other radios due to the connection_timeout. 
    // This is a period of time that the program blocks and waits for the radio to connect before giving up (and incrementing 
    // the retry count). This means if the connection timeout is, say, 1.5 seconds, the program will hang 1.5 seconds 
    // max_radio_retry_reconnect_count times waiting for that radio to come back online
    "max_radio_retry_reconnect_count": 10,

    // object - The amount of time to wait for a radio to connect before deciding that either there is no radio (at startup), 
    // or incrementing the retry count for a radio (during execution if a radio becomes unresponsive)
    "connection_timeout": {

        // int - second count
        "seconds": 0,

        // int - microsecond count
        "microseconds": 500000
    },

    // object - By default there are no loggers, so if you omit loggers all together then nothing will be saved to csv files. 
    // Each logger will generate a csv file with a header and at least a single row of data at startup
    "loggers": {

        // object - A logger will create a CSV file with the columns completely determined by which properties are present in the 
        // logger object. The name of the csv file will be LoggerName [YYYY-MM-dd at hhhh].csv where hhhh is military 24 hour time.
        // As mentioned above, there are no default loggers, so leaving loggers out of the config, or leaving an empty loggers object
        // will cause no log files to be generated
        "LoggerName": {
            
            // string - the folder where this logger should be saved
            "dir_path": "/home/ubuntu/csvlogs",

            // int - scan period in milliseconds - ie scan the radios every period ms. A value of 0 means as fast as you can
            "period": 0,

            // object - property for TX ptt status
            "ptt_status": {
                
                // string - title that appears in column header
                "title": "PTT",

                // bool - should a change in ptt status between the current scan and previous scan for any transmitter add an entry
                // to the csv log file
                "change": false,

                // string - if any transmitter has it's ptt status equal to any of the statuses listed here, an entry is added 
                // to the csv log file. Including all options looks like "OFF | LOCAL | REMOTE | TEST_RF" and only one option is "LOCAL" 
                // or "REMOTE" or "TEST_RF" etc. Mix and match however is needed
                "equal": ""
            },

            // object - property for RX squelch status
            "squelch_status": {

                // string - title that appears in column header
                "title": "Squelch",

                // bool - should a change in squelch status between the current scan and previous scan for any receiver add an entry
                // to the csv log file
                "change": false,

                // string - if any receiver has it's squelch status equal to any of the statuses listed here, an entry is added 
                // to the csv log file. Including all options looks like "OPEN | CLOSED" and only one option is "OPEN" or "CLOSED"
                "equal": ""
            },

            // object - property for TX forward power
            "forward_power": {
                // string - title that appears in column header
                "title": "Fwd Pwr",

                // float - will never trigger a log entry if omitted (thats what no default means)
                // If ever the value is less than "less_than", add entry to log csv
                "less_than": 0.0, // (no default)

                // float - will never trigger a log entry if omitted (thats what no default means)
                // If ever the value is greater than "greater_than", add entry to log csv
                "greater_than": 0.0:, // (no default)

                // float - will never trigger a log entry if omitted (thats what no default means)
                // If ever the value during this radio scan is "change" different than previous scan, add log entry to csv
                "change": 0.0, // (no default)

                // float - will never trigger a log entry if omitted (thats what no default means)
                // If ever the value during this radio scan is "percent_change" percent different than previous scan, add log entry to csv.
                // Percent difference is calculated (abs(cur_val - prev_val) / abs(cur_val)) * 100
                // This is a percent not fraction - use 0 to 100 not 0 to 1.
                "percent_change": 0.0, // (no default)
            },

            // object - property for TX reverse power
            "reverse_power": {
                // string - title that appears in column header
                "title": "Rev Pwr",

                // float - will never trigger a log entry if omitted (thats what no default means)
                // If ever the value is less than "less_than", add entry to log csv
                "less_than": 0.0, // (no default)

                // float - will never trigger a log entry if omitted (thats what no default means)
                // If ever the value is greater than "greater_than", add entry to log csv
                "greater_than": 0.0:, // (no default)

                // float - will never trigger a log entry if omitted (thats what no default means)
                // If ever the value during this radio scan is "change" different than previous scan, add log entry to csv
                "change": 0.0, // (no default)

                // float - will never trigger a log entry if omitted (thats what no default means)
                // If ever the value during this radio scan is "percent_change" percent different than previous scan, add log entry to csv.
                // Percent difference is calculated (abs(cur_val - prev_val) / abs(cur_val)) * 100
                // This is a percent not fraction - use 0 to 100 not 0 to 1.
                "percent_change": 0.0, // (no default)
            },

            // object - property for TX vswr
            "vswr": {
                // string - title that appears in column header
                "title": "VSWR",

                // float - will never trigger a log entry if omitted (thats what no default means)
                // If ever the value is less than "less_than", add entry to log csv
                "less_than": 0.0, // (no default)

                // float - will never trigger a log entry if omitted (thats what no default means)
                // If ever the value is greater than "greater_than", add entry to log csv
                "greater_than": 0.0:, // (no default)

                // float - will never trigger a log entry if omitted (thats what no default means)
                // If ever the value during this radio scan is "change" different than previous scan, add log entry to csv
                "change": 0.0, // (no default)

                // float - will never trigger a log entry if omitted (thats what no default means)
                // If ever the value during this radio scan is "percent_change" percent different than previous scan, add log entry to csv.
                // Percent difference is calculated (abs(cur_val - prev_val) / abs(cur_val)) * 100
                // This is a percent not fraction - use 0 to 100 not 0 to 1.
                "percent_change": 0.0, // (no default)
            },

            // object - property for RX agc
            "agc": {
                // string - title that appears in column header
                "title": "AGC",

                // float - will never trigger a log entry if omitted (thats what no default means)
                // If ever the value is less than "less_than", add entry to log csv
                "less_than": 0.0, // (no default)

                // float - will never trigger a log entry if omitted (thats what no default means)
                // If ever the value is greater than "greater_than", add entry to log csv
                "greater_than": 0.0:, // (no default)

                // float - will never trigger a log entry if omitted (thats what no default means)
                // If ever the value during this radio scan is "change" different than previous scan, add log entry to csv
                "change": 0.0, // (no default)

                // float - will never trigger a log entry if omitted (thats what no default means)
                // If ever the value during this radio scan is "percent_change" percent different than previous scan, add log entry to csv.
                // Percent difference is calculated (abs(cur_val - prev_val) / abs(cur_val)) * 100
                // This is a percent not fraction - use 0 to 100 not 0 to 1.
                "percent_change": 0.0, // (no default)
            },

            // object - property for RX line_level
            "line_level": {
                // string - title that appears in column header
                "title": "Line Lvl",

                // float - will never trigger a log entry if omitted (thats what no default means)
                // If ever the value is less than "less_than", add entry to log csv
                "less_than": 0.0, // (no default)

                // float - will never trigger a log entry if omitted (thats what no default means)
                // If ever the value is greater than "greater_than", add entry to log csv
                "greater_than": 0.0:, // (no default)

                // float - will never trigger a log entry if omitted (thats what no default means)
                // If ever the value during this radio scan is "change" different than previous scan, add log entry to csv
                "change": 0.0, // (no default)

                // float - will never trigger a log entry if omitted (thats what no default means)
                // If ever the value during this radio scan is "percent_change" percent different than previous scan, add log entry to csv.
                // Percent difference is calculated (abs(cur_val - prev_val) / abs(cur_val)) * 100
                // This is a percent not fraction - use 0 to 100 not 0 to 1.
                "percent_change": 0.0, // (no default)
            }
        }
    }
}
```